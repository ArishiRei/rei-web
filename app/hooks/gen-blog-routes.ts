import { promises as fs } from 'node:fs'
import { resolve } from 'node:path'
import type { 
  BlogRouteInfo, 
  BlogRouteGenerator, 
  ContentTree, 
  ContentTreeNode,
  BlogRouteDiscoveryOptions
} from '../types/blog'
import { BlogRouteDiscoveryError, BlogRouteDiscoveryErrorCodes } from '../types/blog'

// Performance optimization: Cache for parsed content tree
let contentTreeCache: { 
  tree: ContentTree | null
  lastModified: number
  filePath: string | null
} = {
  tree: null,
  lastModified: 0,
  filePath: null
}

/**
 * Reads and caches the content tree for performance optimization
 * 
 * @param treePath - Path to the content tree file
 * @returns Parsed content tree
 */
async function getCachedContentTree(treePath: string): Promise<ContentTree> {
  try {
    const stats = await fs.stat(treePath)
    const lastModified = stats.mtime.getTime()
    
    // Return cached tree if file hasn't changed
    if (contentTreeCache.tree && 
        contentTreeCache.filePath === treePath && 
        contentTreeCache.lastModified === lastModified) {
      return contentTreeCache.tree
    }
    
    // Read and parse the tree file
    const treeContent = await fs.readFile(treePath, 'utf-8')
    let tree: ContentTree
    
    try {
      tree = JSON.parse(treeContent)
    } catch (parseError) {
      throw new BlogRouteDiscoveryError(
        `Failed to parse content tree JSON: ${parseError}`,
        BlogRouteDiscoveryErrorCodes.TREE_FILE_INVALID,
        treePath
      )
    }
    
    // Update cache
    contentTreeCache = {
      tree,
      lastModified,
      filePath: treePath
    }
    
    return tree
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      throw new BlogRouteDiscoveryError(
        `Content tree file not found: ${treePath}`,
        BlogRouteDiscoveryErrorCodes.TREE_FILE_NOT_FOUND,
        treePath
      )
    }
    throw error
  }
}

/**
 * Finds the blog directory in the content tree with optimized traversal
 * 
 * @param tree - Content tree to search
 * @param treePath - Path to the tree file (for error reporting)
 * @returns Blog directory node
 */
function findBlogDirectory(tree: ContentTree, treePath: string): ContentTreeNode {
  if (!tree.tree || typeof tree.tree !== 'object') {
    throw new BlogRouteDiscoveryError(
      'Content tree structure is invalid: missing tree property',
      BlogRouteDiscoveryErrorCodes.INVALID_CONTENT_STRUCTURE,
      treePath
    )
  }
  
  // Optimized search: use find instead of filter for early termination
  const blogDir = tree.tree.children?.find(
    (item: ContentTreeNode) => item.type === 'dir' && item.name === 'blog'
  )
  
  if (!blogDir) {
    throw new BlogRouteDiscoveryError(
      'Blog directory not found in content tree',
      BlogRouteDiscoveryErrorCodes.BLOG_DIR_NOT_FOUND,
      treePath
    )
  }
  
  return blogDir
}

/**
 * Discovers blog routes from the content tree structure
 * 
 * This function reads the _rei_tree.json file generated by the content system
 * and extracts all blog post routes for static generation.
 * 
 * @param options - Configuration options for route discovery
 * @returns Array of blog route paths for static generation
 * @throws BlogRouteDiscoveryError when route discovery fails
 */
export async function discoverBlogRoutes(
  options: BlogRouteDiscoveryOptions = {}
): Promise<string[]> {
  const { 
    cwd = process.cwd(), 
    treeFilePath = 'public/_content/_rei_tree.json' 
  } = options
  
  const treePath = resolve(cwd, treeFilePath)
  
  try {
    const tree = await getCachedContentTree(treePath)
    const blogDir = findBlogDirectory(tree, treePath)
    
    if (!blogDir.children) {
      console.warn('[gen-blog-routes] Blog directory exists but has no children')
      return []
    }
    
    // Optimized route extraction with pre-allocated array
    const routes: string[] = []
    routes.length = blogDir.children.length // Pre-allocate for better performance
    let routeIndex = 0
    
    // Extract routes from blog posts with optimized loop
    for (const item of blogDir.children) {
      if (item.type === 'md' && item.name) {
        // Convert filename to slug (remove .md extension)
        const slug = item.name.replace(/\.md$/, '')
        routes[routeIndex++] = `/blog/${slug}`
      }
    }
    
    // Trim array to actual size
    routes.length = routeIndex
    
    return routes
  } catch (error) {
    if (error instanceof BlogRouteDiscoveryError) {
      throw error
    }
    
    throw new BlogRouteDiscoveryError(
      `Unexpected error during route discovery: ${error}`,
      BlogRouteDiscoveryErrorCodes.INVALID_CONTENT_STRUCTURE,
      treePath
    )
  }
}

/**
 * Extracts detailed blog route information from the content tree
 * 
 * This function provides more detailed information about each blog post
 * including metadata and file paths for advanced route generation scenarios.
 * 
 * @param options - Configuration options for route discovery
 * @returns Array of detailed blog route information
 * @throws BlogRouteDiscoveryError when route discovery fails
 */
export async function extractBlogRouteInfo(
  options: BlogRouteDiscoveryOptions = {}
): Promise<BlogRouteInfo[]> {
  const { 
    cwd = process.cwd(), 
    treeFilePath = 'public/_content/_rei_tree.json',
    sortByDate = true
  } = options
  
  const treePath = resolve(cwd, treeFilePath)
  
  try {
    const tree = await getCachedContentTree(treePath)
    const blogDir = findBlogDirectory(tree, treePath)
    
    if (!blogDir.children) {
      console.warn('[gen-blog-routes] Blog directory exists but has no children')
      return []
    }
    
    // Pre-allocate array for better performance
    const routeInfos: BlogRouteInfo[] = []
    routeInfos.length = blogDir.children.length
    let infoIndex = 0
    
    // Extract detailed route information from blog posts
    for (const item of blogDir.children) {
      if (item.type === 'md' && item.name && item.urlPath) {
        // Convert filename to slug (remove .md extension)
        const slug = item.name.replace(/\.md$/, '')
        
        const routeInfo: BlogRouteInfo = {
          slug,
          jsonPath: item.urlPath,
          urlPath: `/blog/${slug}`,
          metadata: {
            title: item.meta?.title,
            date: item.meta?.date,
            description: item.meta?.description,
            tags: item.meta?.tags,
            cover: item.meta?.cover
          }
        }
        
        routeInfos[infoIndex++] = routeInfo
      }
    }
    
    // Trim array to actual size
    routeInfos.length = infoIndex
    
    // Sort by date descending (newest first) if requested
    if (sortByDate && routeInfos.length > 1) {
      // Use optimized sort with pre-computed timestamps
      const sortableInfos = routeInfos.map(info => ({
        info,
        timestamp: info.metadata.date ? new Date(info.metadata.date).getTime() : 0
      }))
      
      sortableInfos.sort((a, b) => b.timestamp - a.timestamp)
      
      // Extract sorted infos
      for (let i = 0; i < sortableInfos.length; i++) {
        const sortableInfo = sortableInfos[i]
        if (sortableInfo?.info) {
          routeInfos[i] = sortableInfo.info
        }
      }
    }
    
    return routeInfos
  } catch (error) {
    if (error instanceof BlogRouteDiscoveryError) {
      throw error
    }
    
    throw new BlogRouteDiscoveryError(
      `Unexpected error during route info extraction: ${error}`,
      BlogRouteDiscoveryErrorCodes.INVALID_CONTENT_STRUCTURE,
      treePath
    )
  }
}

/**
 * Creates a blog route generator instance
 * 
 * This implements the BlogRouteGenerator interface for integration
 * with Nuxt's build process and prerender configuration.
 * 
 * @param options - Configuration options for route discovery
 * @returns BlogRouteGenerator instance
 */
export function createBlogRouteGenerator(
  options: BlogRouteDiscoveryOptions = {}
): BlogRouteGenerator {
  let discoveredRoutes: string[] = []
  
  return {
    async discoverRoutes(): Promise<string[]> {
      const startTime = performance.now()
      
      try {
        discoveredRoutes = await discoverBlogRoutes(options)
        
        const endTime = performance.now()
        const duration = Math.round(endTime - startTime)
        
        console.log(`[gen-blog-routes] Route discovery completed in ${duration}ms`)
        console.log(`[gen-blog-routes] Discovered ${discoveredRoutes.length} blog routes`)
        
        return discoveredRoutes
      } catch (error) {
        const endTime = performance.now()
        const duration = Math.round(endTime - startTime)
        
        if (error instanceof BlogRouteDiscoveryError) {
          console.error(`[gen-blog-routes] Route discovery failed after ${duration}ms: ${error.message}`)
          console.error(`[gen-blog-routes] Error code: ${error.code}`)
          if (error.filePath) {
            console.error(`[gen-blog-routes] File path: ${error.filePath}`)
          }
        } else {
          console.error(`[gen-blog-routes] Unexpected error during route discovery after ${duration}ms:`, error)
        }
        return []
      }
    },
    
    registerRoutes(routes: string[]): void {
      // This method can be used to register routes with Nuxt's prerender system
      // The actual registration will be handled in the Nuxt configuration
      console.log(`[gen-blog-routes] Registering ${routes.length} blog routes for static generation`)
      
      // Only log individual routes in development for performance
      if (process.env.NODE_ENV === 'development') {
        routes.forEach(route => {
          console.log(`[gen-blog-routes] - ${route}`)
        })
      }
    }
  }
}

/**
 * Clears the content tree cache
 * 
 * This function can be used to force a fresh read of the content tree
 * during development or when content has been updated.
 */
export function clearContentTreeCache(): void {
  contentTreeCache = {
    tree: null,
    lastModified: 0,
    filePath: null
  }
  console.log('[gen-blog-routes] Content tree cache cleared')
}